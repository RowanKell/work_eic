# Notes Wed June 19

## Neural Network approach

#### Feature spaces

(100k events - 80k train 20k test, 50-50 split pi/mu)

1. EDep per layer (28)
   1. 50% accuracy
2. pixels per layer (28)
   1. 91.755% accuracy



This makes 0 sense

#### model exploration

dropout

1. On pixels per layer: 91.135

L1/L2 normalization

Activation functions (ReLU as default):

1. Tanh
   1.  89.005%
2. Sigmoid
   1. 50% accuracy
3. LeakyReLU
   1. 91.78
4. SiLU
   1. 91.7
5. GELU
   1. 91.74

## Fitting z dependence on % of photons reaching sensor

![image-20240619164627594](/home/rowan/.config/Typora/typora-user-images/image-20240619164627594.png)

### function:

a / (x + b) + c

1. a = 494.98
2. b = 9.9733
3. c = -0.16796

### Result

1. seems that adding the z dependence lowers accuracy to 85%...

# Notes

1. If ever gettinga a mysterious CUDA error, switch device to cpu and run again - will get actual error







# KLM Meeting - 2pm



Questions / assumptions

1. scintillator bar length - is 1.5 or 2.5 a better option to work with right now?
2. SiPM - how large are they, how many per bar, how many pixels?
   1. Anything else about how we can more accurately model them in the simulation

meeting notes

1. timing + SiPM shape
   1. look at multiple arrivals - first staircase, then pulse shape - need to throw in dark arrivals
   2. just put active area of sipms in right place on bar - 12 4x4mm points - 2x6 array of - 4050HS
   3. ideally need a distribution for each photon, then draw a time for each photon
   4. need to know what the answer for timing
2. simulate a range of lengths and scintillator materials
3. 

next steps for me

1. May want to look at timing parametrization
   1. See time of hit for photons generated by hits at different positions - can we just use position as input and nothing else

# Notes Friday June 21st

Timing

1. Use z position as parameter
2. Parameterize for each photon for each hit?

Plan

1. Use optical photon one layer setup
2. Simulate opt ph over a range of theta
3. for each photon, 



## New plan - Timing

### Angle

1. Look at angle dependence of timing info
2. See if the shape of the timing distribution depends on angle
3. Plan
   1. Shoot from different positions to hit one spot at different angles

### Test if # of photons independent of timing distribution

1. Bin by energy and see if distributions are different at diff energies
   1. I.e if 1GeV and 5GeV have same timing distributions then we are good



# Group meeting

1. Run some EIC events through my affinity calculations, see if me and penn get the same thing
2. solenoid
   1. 2.5 tesla
   2. 120 cm
3. lower momenta -> higher angle -> more iron



EIC sim

1. is there a dependence of timing distribution on track angle
   1. could be that the emission angle is depending on the track angle





# June 24

## Mu Pi separation

1. Ian's code works well for 1GeV pions and muons at fixed theta, but seems like when theta is varied the accuracy will go down as more muons stop after first few layers (not sure why)

## Timing resolution

### Independence of primary energy and timing distribution

1. Need to bin timing distribution by energy
2. Seems that energy and timing distribution are uncorrelated, hard to tell exactly though

![](/home/rowan/Downloads/travel_time_energy_10k_20_bins.jpeg)

### Independence of # photons (energy dep) and timing

1. Unclear if there is a correlation or not, may need to run more events to get higher statistics

![](/home/rowan/Downloads/travel_time_num_photons_10k_20_bins.jpeg)

1. Need to run simulation where we get different angles / diff energy deposit and diff # of photons without the # photons being correlated with the position (and hence the travel time)

## New sim: same hit position with different angles / energy deposits

1. Needed some data where the travel distance of the photons is constant (to not affect timing) but the energy deposit (and hence # of photons) is varied. By just changing theta we change the hit position too, so we need to adjust the gun position such that we always hit the same position (like a focal point). Data is running as of 6/24 5pm, needs to be analyzed tomorrow
   1. Should make similar plots to the ones before, this time with # of optical photons or energy dep or theta angle as the x axis (and binning) and the travel time on the y axis

# June 25

1. Ran the simulations and now have plots for those
   1. Seems like theres a correlation with angle but this seems to just be related to the position of the hit, not the energy dep/# of photons as the range of deviation is so small
   2. Likely what happened (and this seems to be true) is that the angles + gun positions line up the entry point of the particle, but the track goes through different points, so the average z value across all hits is directly proportional to the angle, hence we see a linear slope

# June 26

1. Investigating second peak
   1. Maybe from photons produced by secondaries? Now cutting out photons produced by secondaries
   2. Appears that cutting out secondaries fixes the issue, we now get a pretty clean distribution

## Normalizing flows to model the timing pdf

1. Can use regular normalizing flow and bin by position
2. Can try conditional flow where the conditional variable is the position

First test

1. Normalizing flow with 1 feature, travel time

Other idea

1. Use one travel time distribution from middle of bar, then add or subtract time as a function of the z position

### Emission time

1. Travel time is needed, but emission time is also needed if photons are emitted at different times from the hit time of the charged track 

##### Need to calculate

1. Idea: shoot from diff x positions where the time it takes for the mu to travel to the scintillator is measurable so we can make sure emission time is shifted according to this distance
   1. If we move the particle gun back, the emission time should be shifted x / v nanoseconds
2. Currently investigating with 0.1 GeV muon gun to see if there is any dependence on gun x position

![image-20240627121347119](/home/rowan/.config/Typora/typora-user-images/image-20240627121347119.png)

From this we can clearly see that the emission time (means) are linear to the x_pos. Thus, we must parameterize the emission time by taking a distribution of the emission times and shifting it based on the hit time

##### Current parameterization overview

Overview

1. Main aspects
   1.  \# of photons
      1. Calculated using $\frac{1}{x}$​​ where x is the z position of hit
         1. Variation_percent.ipynb
      2. Take fraction of photons that reach sensor based on hit position
   2. Timing
      1. Draw from distribution of emission times
         1. x_pos.ipynb
      2. Draw from distribution of travel times
         1. Variation_time.ipynb
      3. Use one bar simulation to get these distributions
         1. Only use photons that reach sensor
         2. Emission time after hit has distribution, time between gun and hit can be calculated using energy and distance
   3. Together, should give us timing for every pixel, and we can use this to calculate the pulse shape of the SiPM output.

# AID2E

1. Objectives
   1. FOM
      1. Use AUC of roc_curve as metric
   2. 4 or 5 maximum, 3 would be better
2. Parameters
   1. Overall iron 
   2. Overall scintillator
   3. number of layers
   4. Barrel Length? need to somehow offset this
   5. Inner + outer radius
      1. outer radius as objective - made it as small as possible
3. May want to divide up by different momentum ranges
   1. 2 momentum ranges
   2. 0.5-3 and 3-10
4. Change # layers and ratio of iron to scintillator
5. Variable iron thickness?
6. Once we have shower shape we can do more



Framework code

1. Botorch tutorials are useful
2. parameters.config
   1. JSON for defining each parameter in xml that can be edited
   2. min, max, nominal values, units
   3. Need reasonable values for # of layers (easy) and ratio of iron to scint
3. wrapper.py
   1. loads botorch (bayesian optimization) and axe (experiment management) libraries
   2. Only needs small edits
   3. Suggests a design point
   4. edits xml, creates new geometry
4. runTestsAndObjectiveCalc.py (maybe)
   1. Run simulation jobs
      1. Run 2 jobs per design point (one per momentum range)
   2. Calculates objectives

Plan

1. setting up parameters.config
2. Manually run stuff
3. set lowerbound on objective as 10% lower than expected lower